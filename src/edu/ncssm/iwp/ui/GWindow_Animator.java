package edu.ncssm.iwp.ui;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

import javax.swing.Box;
import javax.swing.JApplet;
import javax.swing.JButton;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTabbedPane;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;

import edu.ncssm.iwp.exceptions.DataStoreException;
import edu.ncssm.iwp.exceptions.InvalidEquationException;
import edu.ncssm.iwp.exceptions.UnknownTickException;
import edu.ncssm.iwp.exceptions.UnknownVariableException;
import edu.ncssm.iwp.graphicsengine.GRender;
import edu.ncssm.iwp.math.MVariablesFactory;
import edu.ncssm.iwp.objects.DObject_Time;
import edu.ncssm.iwp.plugin.IWPAnimated;
import edu.ncssm.iwp.problemdb.DProblem;
import edu.ncssm.iwp.problemdb.DProblemManager;
import edu.ncssm.iwp.problemdb.DProblemManager_FileOpen_gui;
import edu.ncssm.iwp.problemdb.DProblemState;
import edu.ncssm.iwp.problemdb.ProblemListener;
import edu.ncssm.iwp.problemdb.ProblemWriter;
import edu.ncssm.iwp.ui.widgets.GOutput_Number;
import edu.ncssm.iwp.ui.widgets.GOutput_Timer;
import edu.ncssm.iwp.util.IWPLog;
import edu.ncssm.iwp.util.IWPLogPopup;
import edu.ncssm.iwp.util.buildversion.BuildVersion;

/**
 * GWindow_Animator handles the core frame of the IWP_Animator Swing display. It
 * is the class responsible for the JFrame and managing everything below.
 *
 * There are two constructors, one that takes no arguments, and constructs the
 * JFrame for the APPLICATION window, and a second that takes a Swing Container
 * as an arugment for the parent frame, and this is for APPLET mode.
 *
 * This object holds the DProblem, and the DProblem state.
 *
 * There are two main activities, zero and tick.
 *
 * A 'zero' activity will create a fresh DProblemState from the problem, and
 * send a zero (reset) signal to all the visual elements. This happens when a
 * new problem is loaded or the user presses, 'reset'.
 *
 * The 'tick' activity is generated by a child thread, and is called when the
 * animation is moving forward or backwards. tick gets called on the problem
 * state (where the tickCount is kept) and then all the visual elements. THis
 * causes the GRender, GOutput panes to update.
 *
 *
 * 2007-Feb-01 IWP3. I am now using the Plugin Interface: IWPCalculated to order
 * the objects into the proper calculation order. This has been an outstanding
 * problem since the very first verison of IWP.
 *
 *
 * @author brockman
 *
 */

public class GWindow_Animator implements WindowListener, ActionListener,
        ProblemListener {
    public static int MODE_APPLICATION = 1;

    public static int MODE_APPLET = 2;

    public static int MODE_DESIGNER_VIEW = 3;

    // This holds APPLIACTION / APPLET / DESIGNER_VIEW
    int applicationMode;

    boolean errorInProblem;

    // Frames per second. This is inverted to determine the milisec sleep
    // between ticks.
    public static double DEFAULT_FRAME_RATE = 20;

    // brockman 2005-Oct-16. Here is a default, so that the GUI can draw itself
    // w/o nullpointers.
    // NOTE: problem should NEVER be null.
    DProblem problem = new DProblem("constructor default",
            "constructor default");

    // This is out child thread that generates events that we translate
    // into ticks in the logic below.
    GWindow_Animator_Ticker ticker;

    // this holds a hook to either the JFrame,
    // or the applet Content pane. brockman 2005-oct-16
    private GFrame frame = null; // This is only set when there's a frame.

    private Container parentContainer = null;

    private DProblemState problemState;

    // The animateds array holds the list of all widgets that needs to have the
    // zero and the think calls passed down to them. All objects of this array
    // must implement interface GWindow_Animated. brockman 2005-oct-16
    Collection animationListeners = new ArrayList(100);

    // Visual pop up to allow the user to browse the packaged / companion files.
    // 2006-Aug-18 brockman
    GWindow_PackagedProblemBrowser packagedProblemBrowser = null;

    DProblemManager manager;

    GAboutDialogue about = null;

    // See bottom of this class for GUI

    public static final int WINDOW_WIDTH = 700;

    public static final int WINDOW_HEIGHT = 700;

    /**
     * Application Mode Startup
     */
    public GWindow_Animator(int applicationMode)
    {
        this.applicationMode = applicationMode;

        manager = new DProblemManager();

        // brockman 2005-oct-16. If application mode, use a new frame.
        // if applet mode, uise the applet's frame/contentPane.
        frame = new GFrame();
        frame.addWindowListener(this);
        frame.setTitle("IWP Animator (Version " + BuildVersion.VERSION + ")");
        frame.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
        frame.centerOnScreen();

        // build and set the ticker ticking at 1 per second.
        constructTicker();

        this.parentContainer = frame.getContentPane();
        _constructGui(this.parentContainer);

        // zero everything out before showing.
        masterZero();

        // show me.
        frame.setVisible(true);
        frame.requestFocus(); // This should prevent the animator from
        // 'slipping behind' browsers;
    }

    /**
     * Applet mode startup
     *
     * @param iProblem
     * @param parent
     */
    public GWindow_Animator(Container appletParent) {
        this.applicationMode = MODE_APPLET;
        this.parentContainer = appletParent;

        manager = new DProblemManager();

        // build and set the ticker ticking at 1 per second.
        constructTicker();

        _constructGui(this.parentContainer);

        // zero everything out before showing.
        masterZero();
    }

    // -------------------------------------------------------------------
    /**
     * Get a reference to the currently displayed problem
     */
    public DProblem getProblem() {
        return this.problem;
    }

    /**
     * Get a reference to the current problem state.
     *
     * @return
     */
    public DProblemState getProblemState() {
        return this.problemState;
    }

    /**
     * Stop the current animation and reload a new problem. This call is made
     * from teh designer hook. brockman 2005-oct-16
     *
     * Caveat: This assumes that the UI has been constructed.
     *
     * @param iProblem
     */
    public void viewProblem(DProblem iProblem) {
        if (iProblem == null) {
            IWPLog.warn(this,
                    "Passed a null problem into viewProblem. Ignoring.");
            return;
        }

        pauseTicker();

        this.problem = iProblem;

        // 2007-Jun-07 Brockman IWP3. To get rid of the +.0000000000000000001 double precision errors, I
        // can use an alternate number storage mechanism
        // System.err.println("DEBUG: setting precision mode to: " + problem.getTime().getUsePreciseCalculations() );

        MVariablesFactory.setPrecise(problem.getTime().getUsePreciseCalculations());

        // 2007-Sep-02: We need to reset the Window dimensions based on the problem here.
        // Previously we were only building the 'Window' tab in the animator when the gui
        // was first constructed. This caused the values to all be default 10, -10, 10, -10.
        // TODO Brockman bookmark
        
        resizePanel.resetValuesFromProblem(problem.getWindow());

        // 2007-Oct-20 Cory
        // every time a problem is loaded, we want to see if the shwAllDataAvailable flag
        // is set. If so, enable the button. If not, disable
        if ( problem.getWindowObject().isShowAllDataAvailable() ) { 
        	this.showData.setEnabled(true);
        } else {
        	this.showData.setEnabled(false);
        }
        
        masterZero();

        // Don't make the ticker run on startup.
        // resumeTicker();
    }

    /**
     * This is called by the designer. It doesn't actually destroy the connected
     * animator window, just hides it on close. This turns it back on
     *
     * @param mode
     */
    public void setVisible(boolean mode) {

        if (frame != null) {
            frame.setVisible(mode);
        }
    }

    // --------------------------------------------------------------
    // The two master functions. zero and tick. See Class javadoc.

    /**
     * Brockman 2005-oct-16. Getting rid of reset and init ocne and for all and
     * replacing with think(problemState) and zero(problem) and constructGui()
     * [to be called in constructor]
     *
     * @param problem
     */

    public synchronized void masterZero()
    {
        errorInProblem = false;
        
        try {

            // now, call zero on the problem, by making a new problem state.
            // Problem state has no zero, to make a fresh one, you
            // construct it.
            problemState = new DProblemState(problem);

            // IWP3:re-order all of the problem objects based on the
            // new interface plugin.IWPCalculated.

            problem.reorderProblemObjectsBySymbolicDependency();

            // zero all the objects in the problem.
            zeroProblemObjects();

            // then call zero on all the UI elements.
            zeroAnimationListeners();

        } catch (Exception e) {
            // Throw a popup if something bad happens.
            this.visualException(e);
        }

        // IWP3: We also must calculate the position zero or else we're going to
        // have missing index 0 data
        masterTick(true);

        myRepaintAll();
    }

    /**
     * This method begins the cascade of think(problemState) calls down to each
     * widget.
     *
     * This is synchronized so that only one thread can call it at a time.
     *
     * This is going to be called by the GWindow_ANimator_ticker.
     */
    public synchronized void masterTick(boolean forceTick) {
        if (errorInProblem) {
            IWPLog.error(this,
                    "There is an error with the problem. Not ticking");
            return;
        }

        try {
            // First update the problem state.
            // This should do all the calculations down in
            // the objects.

            // handleTickEvent could be false, but we still have to call it.
            if (problemState.handleTickEvent() || forceTick) {

                // Tick all the objects in the problem.
                // 2007-jun-03 keeping synchronized track if there is a tick
                // going on at the time or not.
                problemState.setTickInProgress(true);
                tickProblemObjects();
                problemState.setTickInProgress(false);

                // Now, tick all the visual elements
                // that GWindow_Animator (this) controls.
                tickAnimationListeners();
            }

            // Did we hit the end time?
            stopIfEndTime();

        } catch (Exception e) {
            problemState.setTickInProgress(false);
            this.visualException(e);
        }

        myRepaintAll();
    }

    /**
     * A paint routine called every zero + tick.
     *
     */
    public synchronized void myRepaintAll() {
        // The repaint is necessary, as it tells the graphic canvas to update
        // too.
        // 2006-Aug-23 brockman
        parentContainer.invalidate();
        parentContainer.validate();
        parentContainer.repaint();
    }

    //
    // DObject zeroing and ticking.

    private synchronized void zeroProblemObjects()
            throws InvalidEquationException, UnknownTickException,
            UnknownVariableException {
        // Does this need to go in order?!
        // Yes, we want to do time first
        DObject_Time time = this.getProblem().getTimeObject();
        time.zero(this.getProblem(), this.getProblemState());
        
        // Zeroing out the windows in order to read the show gridNumbersProperty
        // 20-Oct-07 Cory
        this.getProblem().getWindowObject().zero(this.getProblem(), this.getProblemState());
        

        for (Iterator i = this.getProblem().getObjectsForTicking().iterator(); i
                .hasNext();) {

            Object o = (Object) i.next();

            if (o instanceof IWPAnimated) {

                // don't do time twice.
                // IWP3: I shouldn't have to do this check because I should be
                // auto re-ordering time to the top!
                if (o != time) {
                    ((IWPAnimated) o).zero(this.getProblem(), this
                            .getProblemState());
                }
            }

        }

    }

    /**
     * Warning, this is dangeously close ot the iteration done for zeroing.
     *
     * @throws InvalidEquationException
     * @throws UnknownTickException
     * @throws UnknownVariableException
     */

    private synchronized void tickProblemObjects()
            throws InvalidEquationException, UnknownTickException,
            UnknownVariableException {
        // Does this need to go in order?!
        // Yes, we want to do time first

        DObject_Time time = this.getProblem().getTimeObject();

        time.tick(this.getProblemState());

        for (Iterator i = this.getProblem().getObjectsForTicking().iterator(); i
                .hasNext();) {

            Object o = (Object) i.next();

            if (o instanceof IWPAnimated) {

                // don't do time twice.
                // IWP3: I shouldn't have to do this check because I should be
                // auto re-ordering time to the top!
                if (o != time) {
                    ((IWPAnimated) o).tick(this.getProblemState());
                }
            }

        }
    }

    /**
     * IWP3 - core logic to stop time of we're over. Runs at the end of the tick
     * loop.
     *
     */
    private synchronized void stopIfEndTime() {
        DObject_Time time = this.getProblem().getTimeObject();
        if (time.getTime() >= time.getStopTime()) {
            handleTimeStopButtonPress();
        }
    }

    // ------------------------------------------------------------
    // GWindow_Animation LISTENER STUFF Zeroing and Ticking.

    /**
     * Brockman 2005-Oct-16 This method will return the array of all the objects
     * that are listening for animation ticks from the GWindow_Animator.
     *
     * @return
     */

    private synchronized Collection getAnimationListeners() {
        return animationListeners;
    }

    /**
     * Subscribe a new listener to the animation ticking.
     *
     * @param listener
     */

    public synchronized void addAnimationListener(IWPAnimated listener) {
        animationListeners.add(listener);
    }

    /**
     * Send the zero signal to all the animation listeners, like the render
     * pane, and the input / output panes.
     *
     */
    private synchronized void zeroAnimationListeners() throws Exception {
        for (Iterator i = getAnimationListeners().iterator(); i.hasNext();) {
            ((IWPAnimated) i.next()).zero(getProblem(), getProblemState());
        }

        // this is a custom one. Need to make it an animated.
        textArea.setText(getProblem().getDescriptionObject().getText());

        class ScrollToTop implements Runnable {
            JScrollPane scrollPane;

            public ScrollToTop(JScrollPane scrollPane) {
                this.scrollPane = scrollPane;
            }

            public void run() {
                scrollPane.getVerticalScrollBar().getModel().setValue(0);
            }
        }

        textScroll.getVerticalScrollBar().getModel().setValue(0);// move
                                                                    // focus to
                                                                    // top.

        // Queue call to reposition scrollbar
        SwingUtilities.invokeLater(new ScrollToTop(textScroll));

    }

    /**
     * This sends the tick signal to all of the animation listeners.
     *
     * Warning, this is dangeously close ot the iteration done for zeroing.
     *
     * @throws InvalidEquationException
     * @throws UnknownTickException
     * @throws UnknownVariableException
     * @throws Exception
     */

    private synchronized void tickAnimationListeners() throws Exception {
        for (Iterator i = getAnimationListeners().iterator(); i.hasNext();) {
            ((IWPAnimated) i.next()).tick(getProblemState());
        }
    }

    // -------------------- Window Event Handler ------------------

    public synchronized void applicationExit() {
        destroyTicker(); // this is the only palce this is called.

        //IWPLog.info(this, "applicationExit. (mode: " + applicationMode + ")");

        // Exit in the animator kills the whole application in either desktop mode.
        // Note taht exiting from the Animator doesn't prompt the user if they really want to exit.
        if (applicationMode == MODE_APPLICATION || applicationMode == MODE_DESIGNER_VIEW ) {
            System.exit(0);
        } else {
            this.handleTimeStopButtonPress();
            parentContainer.setVisible(false);
        }
    }

    public synchronized void windowClosing(WindowEvent e) {
        // IWP3.
        if (this.applicationMode == MODE_DESIGNER_VIEW) {
            // let the window close, but don't exit.
            this.handleTimeStopButtonPress();
        } else {
            applicationExit();
        }
    }

    public void windowClosed(WindowEvent e) {
    }

    public void windowActivated(WindowEvent e) {
    }

    public void windowDeactivated(WindowEvent e) {
    }

    public void windowDeiconified(WindowEvent e) {
    }

    public void windowIconified(WindowEvent e) {
    }

    public void windowOpened(WindowEvent e) {
    }

    public void actionPerformed(ActionEvent e) {

        if ((e.getSource()) instanceof JButton) {
            JButton source = (JButton) (e.getSource());
            if (source == showData) {
                IWPLog.info(this, "actioncmd " + e.getActionCommand());
                new GWindow_data(problem, problemState);
            } else if (source == showGraph) {
                graph.setVisible(true);

            }
        } else if ((e.getSource()) instanceof JMenuItem) {

            if (e.getSource() == fileItem_open_packaged) {
                IWPLog.debug(this, "opening packaged dialog");

                // lazy loading.
                if (packagedProblemBrowser == null) {
                    packagedProblemBrowser = new GWindow_PackagedProblemBrowser(
                            this);
                }

                packagedProblemBrowser.openDialog();

            } else if (e.getSource() == fileItem_open_local) {

                try {
                    IWPLog.debug(this, "opening local");

                    DProblemManager_FileOpen_gui g = new DProblemManager_FileOpen_gui(
                            manager);

                    g.selectFile();
                    DProblem prob = g.getProblem();
                    viewProblem(prob);

                } catch (DataStoreException dse) {
                    IWPLog.x(this, "ERROR: Unable to open file: "
                            + dse.getMessage(), dse);
                }
            }

            else if (e.getSource() == helpItem_about) {
                // lazy load this since it's not used very often.
                if (about == null) {
                    about = new GAboutDialogue();
                }
                about.setVisible(true);
            }

            else if (e.getSource() == fileItem_exit) {
                applicationExit();
            }

        }

    }

    /*-----------------------------------------------------------------*/
    // TICKER CONTROL
    private synchronized void constructTicker() {
        if (ticker != null) {
            IWPLogPopup.error(this, "Ticker Object is already constructed");
            return;
        }

        ticker = new GWindow_Animator_Ticker(this);
        ticker.start();
    }

    /**
     * This should be called only when exiting the application. When you load
     * problems you don't want to start and stop threads due to a thrash on
     * system resources. There is always one and only one ticker running.
     *
     */

    private synchronized void destroyTicker() {
        if (ticker == null) {
            return;
        }
        if (!ticker.isAlive()) {
            return;
        }

        ticker.setStopFlag();
        ticker.interrupt();

        try {
            ticker.join();
            IWPLog.debug(this, "Successfully Joined Ticker");
        } catch (InterruptedException e) {
            IWPLog.x(this, "Interrupted while trying to join ticker", e);
        }

    }

    private synchronized void pauseTicker() {
        if (ticker == null) {
            return;
        }

        ticker.setSendEvents(false);
    }

    private synchronized void resumeTicker() {
        if (ticker == null) {
            IWPLogPopup.error(this, "Tried to start a null ticker");
            return;
        }

        if (problem == null) {
            IWPLogPopup.error(this, "Problem is null");
        } else {
            ticker.setSendEvents(true, getProblem().getTimeObject().getFps());
        }
    }

    /* Time controls */
    /*
     * These should stop the internal ticker ,, and modify the problem variables
     */

    public synchronized void handleTimeForwardButtonPress() {
        resumeTicker();
        problemState.tickForward();
    }

    public synchronized void handleTimeBackwardButtonPress() {
        resumeTicker();
        problemState.tickBackward();
    }

    public synchronized void handleTimeStopButtonPress() {
        pauseTicker();
        problemState.tickStop();
    }

    public synchronized void handleTimeStepForwardButtonPress() {
        pauseTicker(); // stop all motion before moving around by one.
        problemState.tickStepForward();
        // fire the tick by hand since the thread is dead.
        this.masterTick(true);

    }

    public synchronized void handleTimeStepBackwardButtonPress() {
        pauseTicker(); // stop all motion before moving around by one.
        problemState.tickStepBackward();
        // fire the tick by hand since the thread is dead.
        this.masterTick(true);
    }

    public synchronized void handleTimeResetButtonPress() {
        pauseTicker();
        masterZero();
        myRepaintAll();
    }

    // ---------------------------------------------------------
    // Error message display.

    public synchronized void visualException(Exception e) {
        if (!errorInProblem) {

            IWPLogPopup.x(this, e.getMessage(), e);
        }

    }

    // --------------------------------------------------------------------
    // These are callbacks that are triggered by ProblemServer Client events

    // public void loadProblem ( DProblem problem )
    // loadProblem is not called designProblem
    public synchronized void loadProblem(DProblem problem) {
        viewProblem(problem);
    }

    public synchronized void saveProblem(ProblemWriter output) {
        IWPLogPopup.error(this,
                "Unable to Save Animated problems. How did you get here?");
    }

    // -------------------------------------------------------------------
    // GUI Construction down here for cleanliness.

    // JTabbedPane mainPane; // top level - allows controls and display to be
    // switched.
    JPanel mainPane;

    // Tab 1 -- animation
    JPanel animationPanel = null; // paste tools and GRender here

    JTextArea textArea;

    JScrollPane textScroll;

    JTabbedPane supplimentalSwitch;

    JPanel descriptionPanel;

    GWindow_Animator_setWindowProperties resizePanel;

    GWindow_Animator_setTimeProperties timePanel;

    JButton showData;

    JButton showGraph;

    // 2006-Aug-29 brockman. Getting Graphing working again.
    GWindow_Animator_Graph graph;

    GWindow_Animator_Inputs inputPane;

    GWindow_Animator_Outputs outputPane;

    GWindow_Animator_Time timePane;

    GRender renderPane;

    GOutput_Number gridX;

    GOutput_Number gridY;

    GOutput_Timer outputTime;

    JMenuBar menuBar = new JMenuBar();

    JMenu fileMenu = new JMenu("File");

    JMenu fileItem_open = new JMenu("Open");

    JMenuItem fileItem_open_local = new JMenuItem("Local File");

    JMenuItem fileItem_open_http = new JMenuItem("HTTP Url");

    JMenuItem fileItem_open_packaged = new JMenuItem("Packaged");

    JMenuItem fileItem_exit = new JMenuItem("Exit");

    JMenu helpMenu = new JMenu("Help");

    JMenuItem helpItem_about = new JMenuItem("About IWP");

    /**
     * Construct the layout independent of higher-level container.
     *
     * @param iProblem
     */
    public void _constructGui(Container parentContainer) {
        // 2006-Aug-28 brockman. build the graph window at the start.
        graph = new GWindow_Animator_Graph(this);
        addAnimationListener(graph);

        // 2006-Aug-16 brockman. build the menu bar.
        fileItem_open.add(fileItem_open_local);
        // fileItem_open.add ( fileItem_open_http ); // off for now
        fileItem_open.add(fileItem_open_packaged);
        fileMenu.add(fileItem_open);
        fileMenu.add(fileItem_exit);
        menuBar.add(fileMenu);

        helpMenu.add(helpItem_about);

        menuBar.add(Box.createHorizontalGlue());
        menuBar.add(helpMenu);

        // Now listen for the menu clicks
        fileItem_open_local.addActionListener(this);
        fileItem_open_packaged.addActionListener(this);
        fileItem_open_http.addActionListener(this);
        fileItem_exit.addActionListener(this);
        helpItem_about.addActionListener(this);

        // set up the animation panel
        // set up the
        textArea = new JTextArea();
        textArea.setEditable(false);
        textArea.setWrapStyleWord(true);
        textArea.setLineWrap(true);

        supplimentalSwitch = new JTabbedPane();
        supplimentalSwitch.setMinimumSize(new Dimension(0, 0));
        descriptionPanel = new JPanel(new BorderLayout());

        textScroll = new JScrollPane(textArea,
                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        descriptionPanel.add("Center", textScroll);
        supplimentalSwitch.add("Description", descriptionPanel);

        // set up everything else
        animationPanel = new JPanel(new BorderLayout());
        outputPane = new GWindow_Animator_Outputs(this);
        addAnimationListener(outputPane);

        inputPane = new GWindow_Animator_Inputs(this);
        addAnimationListener(inputPane);

        timePane = new GWindow_Animator_Time(this);
        addAnimationListener(timePane);

        renderPane = new GRender(this);
        addAnimationListener(renderPane);

        // 2007-Jun-04 brockman IWP3 - enforce a minimum size on the render
        // window.
        renderPane
                .setPreferredSize(new Dimension(GRender.WIDTH, GRender.HEIGHT));
        renderPane.setMinimumSize(new Dimension(GRender.WIDTH, GRender.HEIGHT));

        resizePanel = new GWindow_Animator_setWindowProperties(this);
        supplimentalSwitch.add("Window", resizePanel);

        timePanel = new GWindow_Animator_setTimeProperties(this);
        addAnimationListener(timePanel);

        supplimentalSwitch.add("Time", timePanel);

        // the render and description
        // JPanel leftPanel = new JPanel(new BorderLayout());
        // leftPanel.add("North", renderPane);
        // leftPanel.add("Center",descriptionPanel);
        // leftPanel.add("Center",supplimentalSwitch);
        JSplitPane leftSplit = new JSplitPane(JSplitPane.VERTICAL_SPLIT, true,
                renderPane, supplimentalSwitch);
        leftSplit.setOneTouchExpandable(true);

        // tools to the right
        JPanel inputHolder = new JPanel(new BorderLayout());
        inputHolder.add(BorderLayout.NORTH, inputPane);
        JPanel outputHolder = new JPanel(new BorderLayout());
        outputHolder.add(BorderLayout.SOUTH, outputPane);
        JSplitPane ioPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, true,
                new JScrollPane(inputHolder), new JScrollPane(outputHolder));
        ioPane.setResizeWeight(0.5);
        ioPane.setOneTouchExpandable(true);

        JPanel infoPanel = new JPanel(new BorderLayout());
        JPanel buttonPanel = new JPanel(new BorderLayout());

        // some new display coding.
        showData = new JButton("Show All Data");
        showData.addActionListener(this);
        showGraph = new JButton("Show Graph");
        showGraph.addActionListener(this);

        // 2007-Oct-20 Cory
        // The show data button is always added, just dsiabled + enabled on viewProblem()
        showData.setEnabled(true); // start is off enabled.
        buttonPanel.add("North",showData);
        buttonPanel.add(BorderLayout.SOUTH, showGraph);
        infoPanel.add(BorderLayout.NORTH, buttonPanel);
        infoPanel.add(BorderLayout.CENTER, ioPane);
        infoPanel.add(BorderLayout.SOUTH, timePane);
        infoPanel.setPreferredSize(new Dimension(200, 400));

        // add both parts the the "main" of the tab
        // animationPanel.add("Center",leftPanel);
        // animationPanel.add("Center",leftSplit);
        // animationPanel.add("East",infoPanel);

        JSplitPane mainSplit = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
                true, leftSplit, infoPanel);
        mainSplit.setOneTouchExpandable(true);

        // mainPane=new JTabbedPane();
        mainPane = new JPanel();
        mainPane.setLayout(new BorderLayout());
        // mainPane.add("Center",animationPanel);
        mainPane.add(BorderLayout.CENTER, mainSplit);
        // mainPane.addTab("animation",animationPanel);
        // mainPane.addTab("silly", new JPanel());

        // mainPane=new JPanel();
        // mainPane.add(animationPanel);

        // this next line needs to be fiddled with
        // ioPane.setDividerLocation(0.6);
        leftSplit.setDividerLocation(0.75);
        mainSplit.setDividerLocation(0.75);
        renderPane.setSize(new Dimension(350, 350));

        // set the layout and add the core object.

        if (frame != null) {
            frame.setJMenuBar(menuBar);
        } else if (parentContainer instanceof JApplet) {
            ((JApplet) parentContainer).setJMenuBar(menuBar);
        }

        parentContainer.setLayout(new BorderLayout());
        parentContainer.add(BorderLayout.CENTER, mainPane);
    }

}

/**
 * This is the thread that runs the animation forward and backward. This class
 * is now very simple, it just generates evnts for the above.
 *
 * I've swayed back and forth making this less / more copmlicated.
 *
 * @author tbrockman
 *
 */

class GWindow_Animator_Ticker extends Thread {
    private GWindow_Animator parent;

    // Only let it run so quickly. Like an engine govenor.
    private long DEFAULT_LAG_MS = 1000;

    private long MINIMUM_LAG_MS = 5;

    private long lagMS = DEFAULT_LAG_MS; // Important to start out with a

    // decent value.

    private boolean sendEvents = false;

    private boolean stopFlag = false;

    public GWindow_Animator_Ticker(GWindow_Animator iParent) {
        parent = iParent;
    }

    public void run() {
        while (!stopFlag) {


            // sleep a long time only when sending events. Else sleep a short time so I'm
            // very responsive to when the user first presses play.

            try {

                if ( sendEvents ) {
                    if (lagMS < MINIMUM_LAG_MS) {
                        sleep(MINIMUM_LAG_MS);
                    } else {
                        sleep((long) lagMS);

                    }
                } else {
                    // Only sleep 10ms at a time, hungrly waiting for a button press.
                    sleep(10);
                }
            } catch (InterruptedException e) {
                // we have been interrupted -- stopping happends after this
                IWPLog.warn(this, "Tick. INTERRUPTED. lagMS=" + lagMS);
                continue;
            }




            // MASTER TICK EVENT is GENERATED HERE.
            // Brockman 2006-Apr-29
            // Only send it if eventgs are turned on. Rather than trying
            // to create / join the thread, I've just kept it urnning
            // all the time.
            if (sendEvents) {
                parent.masterTick(false);
            }

            // I took this out because it was memory intensive
            /*
             *
             * long wait=idealLagMS - (after.getTime() - before.getTime());
             * lagMS = (int) (wait<0 ? 0 : wait);
             */
            // IWPLog.info(this, "Tick: lagMS=" + lagMS);
            yield();
        }

        IWPLog.info(this, "While loop sleep was interrupted.");
    }

    public void setStopFlag() {
        this.stopFlag = true;
    }

    public void setSendEvents(boolean sendEvents, double fps) {
        this.setLag(fps);
        this.sendEvents = sendEvents;
    }

    public void setSendEvents(boolean sendEvents) {
        this.sendEvents = sendEvents;
    }

    private void setLag(double fps) {
        lagMS = (int) (1000 * (1 / fps));
    }

}
